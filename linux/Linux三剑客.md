#### grep
用于在文件中匹配目标片段，可以与==正则表达式==联动
grep \[参数\] \[筛选规则\] \[目标路径\]
##### 参数列表
有用参数
-i     忽略大小写
-w   整词匹配
-v    反向匹配
-n    显示匹配字段所在的行号
-l     只显示字段所在的文件名称（只关心匹配位置时有用）
-c    返回匹配到的字段数
-r     递归匹配文件夹下的文件
-E    开启正则表达式匹配（弱化版本-e   同时匹配多个字段）
-A    同时显示匹配字段的后n行
-B    同时显示匹配字段的前n行
-C    =     -A -B

无用参数
-q     静默输出
-o     只显示匹配到的部分

##### 与其他命令的联动
* 当没有输出时我们可以使用
```shell
echo $?
```
来判断命令是没有匹配到（输出为0）还是执行出错（输出非0）

* 匹配某一种格式的文件名
```shell
grep -v test *test*
```



#### awk
用于格式化处理文本，格式化的方法用==shell脚本==完成
是一种流编辑器，会逐行处理文本直到把整个文件都处理完成
文本中的每一行叫做一个record，每一个字段叫做一个field，字段可以通过$+n来匹配
awk \[参数\] '模式\{动作\}' \[文件名\]
awk擅长文本格式化，且输出格式化后的结果，因此最常用的动作是print

##### 参数
内部变量
NR   当前的行号（number of records）
NF   当前行的字段数（number of fields）
FS    输入分隔符
OFS 输入分隔符

有用参数
-F    指定字段分割符
-v    定义或修改一个awk内部的变量


没用参数

##### 模式
可以使用$+n来指定字段，$0表示record的完整输出，\$n表示第n个字段，awk提供NF（number of fields）表示最后一个字段的数字
```shell
awk '{print $NF-1}' testfile.txt
```
field默认时按照空格（包含多个空格）进行划分（输入输出都是），也可以用FS（field seperator）和OPS来自定义输入、输出分隔符
```shell
# 输出多个字段，如果没有逗号输出将没有间隔
awk '{print $1,$2,$3}' testfile.txt
# 外层用单引号，内层用双引号，内置变量不得添加引号
awk '{print "output 1",$1,"output 2",$2}'
awk '{print "output 1: "$1,"output 2: "$2}'

# 通过-F或-v指定输入分隔符为“.”
echo '192.168.1.1' | awk -F "." '{print $2}'
echo '192.168.1.1' | awk -v FS="." '{print $2}'

# 通过OFS或-v制定输出分隔符为“”
awk -F ":" -v OFS="===" '{print $1,$NF}' pwd.txt
```
配合重定向可以很容易的改变文件字段的顺序
可以写条件来控制输出
```shell
# 当第二列的值大于等于90时，输出该行所有内容
awk '$2>=90{print $0}' score.txt

# 找到第2到6行的内容，给内容加上行号并输出，内置变量NR不要加$
awk 'NR==2,NR==5{print NR,$0}' testfile.txt
```
判断语句是写在花括号中的
```shell
# 使用if控制输出
awk '{if($2>=90 )print $0}' score.txt
awk '{if($2>=90 )print $1,"优秀"; else print $1,"良好"}' score.txt
```

