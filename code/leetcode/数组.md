# 二分查找
二分查找的思路非常简单，但是变种极其多，因此理解其原理非常重要（以及建立一个可以拿来抄的笔记）
二分查找的流程大致为：假设数组是递增的，只要left比right小，判断数组中间的元素middle和target的关系，如果middle比target小，说明target在left和middle之间，将middle设置为right；如果middle比target大，说明target在middle和right之间，将middle+1设置为left。（注意这只是一种方案，具体依赖于边界条件）


二分查找的一个问题就是如何取边界条件
以上面这个方案为例，我们使用的是
```python
while l < r:
		middle = l + (r - l) // 2
```
可见middle是更偏向left一边的（如果是/正好在中间），注意到我们的循环条件是$left < right$，所以在循环过程中，middle不可能比right大，由于更偏向left，所以是有可能等于left的。因此middle的区间是一个左闭右开区间$[left, right)$，按照这个条件取的初始值也为$left=0, right=len(nums)$，否则会导致末尾的元素搜索不到。
确定这个区间之后，我们就可以确定left和right的变化了。当$middle > target$时，说明target一定在$[left, middle)$或者$[left, middle-1]$区间内，由于我们取不到right，并且确定了middle一定不是target，所以可以取$right = middle$。当$middle < target$时，说明target一定在$(middle, right]$范围内，或者说$[middle + 1, right]$内。由于middle+1我们并没有判断，而且middle是可以取left的，所以$left = middle + 1$。
在上面这个条件内，我们发现由于$left \le middle \lt right$，所以取$right = middle$和$left = middle + 1$导致区间一定是缩小的，这也保证了我们的程序不会无限循环。那么取$right = middle \pm 1$和$left = middle$可以吗？是不行的，因为如果取$right = middle - 1$会导致我们判断不到$middle - 1$，取$middle + 1$不一定会保证区间缩小，同样的$left = middle$也是这个道理。

上面方案的完整程序为（假设数组是递增的）：
```python
def BinarySearch(nums: list[int], target: int) -> int:
		l = 0
		r = len(nums)
		while l < r:
				m = l + (r - l) // 2
				if nums[m] < target:
						r = m
				elif nums[m] > target:
						l = m + 1
				else:
						return m
		return -1
```


按照这个方法也可以推导出一些其他的条件

| $left \lt right$ | $middle = left + (right - left) // 2$ | $middle \in [left, right]$ | $left = middle + 1$ | $right = middle - 1$ |
| ---------------- | ------------------------------------- | -------------------------- | ------------------- | -------------------- |
|                  |                                       |                            |                     |                      |

